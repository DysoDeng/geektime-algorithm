## 第三课：复杂度分析（上）- 如果分析、统计算法的执行效率和资源消耗？

### 时间复杂度（渐进时间复杂度）
- 表示代码执行时间随数据规模增长的变化趋势
#### 时间复杂度分析方法
##### 1、只关注循环执行次数最多的一段代码
```
func cal(n int) {
    sum := 0 // 常量级语句不算做复杂度部分
    // 时间复杂度为 O(n) n为执行了多少次
    for i := 1; i < n; i++ {
        sum = sum + i
    }
}
```

##### 2、加法法则：总时间复杂度等于量级最大的那段代码的复杂度 O(n^2)
```
func cal(n int) {
    sum_1 := 0
    // 此段代码为常量级代码，因为他和n的增长无关，是固定的
    for p := 1; p < 100; ++p {
        sum_1 = sum_1 + p
    }

    sum_2 := 0
    // 此段代码时间复杂度为 O(n)
    for q := 1; q < n; ++q {
        sum_2 = sum_2 + q
    }

    sum_3 := 0
    j := 1
    // 此段代码时间复杂度为 O(n^2)
    for i := 1; i <= n; ++i {
        j = 1
        for ; j <= n; ++j {
            sum_3 = sum_3 + i * j
        }
    }

    // 那么加法法则就是，总的时间复杂度等于量级最大的那段代码时间复杂度，本例为 O(n^2)

    return sum_1 + sum_2 + sum_3
}
```

##### 3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
```
func cal(n int) {
    ret := 0
    // 此段代码原本时间复杂度为 O(n)，但是由于f()函数不是简单的语句，它的时间复杂度为 O(n)
    // 所以函数 cal 总的时间复杂度为 T(n) = O(n) * O(n) = O(n * n) = O(n^2)
    // 这就是乘法法则
    for i := 1; i < n; ++i {
      ret = ret + f(i)
    }
}

// 该函数时间复杂度为 O(n)
func f(n int) int {
    sum := 0
    for i := 1; i < n; ++i {
        sum = sum + i
    }

    return sum
}
```

#### 常用时间复杂度量级（按数量级递增）
- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n^2)、立方阶 O(n^3)、k次方阶 O(n^k)
- 指数阶 O(2^n)
- 阶乘阶 O(n!)
- 其中可以分为`多项式量级`和`非多项式量级`，非多项式量级只有两个：O(2^n)和O(n!)

##### 几种常用多项式复杂度
- O(1): 是指常量级时间复杂度，即代码全为常量级，不管多少代码量，都为 O(1)
- O(logn)、O(nlogn):
```
func main {
    i := 1
    // 变量i从1开始取值，每循环一次就乘2，当i>n时，循环结束；
    // 此时i的取值过程其实就是一个等比数列：i = {2^0, 2^1, 2^2, 2^x}，即 2^x=i
    // 所以求解x则为 x=log2*n
    // 所以这段代码时间复杂度为 O(log2n)
    // PS. 如果将 i = i * 2 改为 i = i * 3，则为 O(log3n)，所以不管是底数为2或3，都为O(logn)
    // 如果一段代码的时间复杂度为O(logn)，那么执行n遍就为 O(nlogn)
    for {
        if i > n {
            break
        }
        i = i * 2
    }
}

// PS. 由于golang 没有while循环，所以该段代码表示的是其它支持while语言中的while循环，如下:
int i = 1;
while(i <= n){
    i = i * 2;
}
```
- O(m+n)、O(m*n):
```
// 当加法法则由两个数据规模决定，并且不能评估出哪一个的量级更大时，
// 就不能使用加法法则而省略掉其中一个，需要将两个都相加，即 O(m+n)
// 但乘法法则继续有效 O(m*n)
func cal(m int, n int) int {
    sum_1 := 0
    // 时间复杂度为 O(m)
    for i := 1; i < m; ++i {
        sum_1 = sum_1 + i
    }

    sum_2 := 0
    // 时间复杂度为 O(n)
    for j := 1; j < n; ++j {
        sum_2 = sum_2 + j
    }

    // 总的时间复杂度为 O(m+n)

    return sum_1 + sum_2
}

```

### 空间复杂度（渐进空间复杂度）
- 表示算法的存储空间与数据规模之间的增长关系
```
func test(n int){
    // 常量级存储空间，和n无关，可以忽略
    i := 0

    // 申请了大小为n的int型数组，占用了n的空间大小
    var array [n]int

    // 下面代码没有占用更多的空间
    for ; i < n; ++i {
        array[i] = i * i
    }

    for i := n - 1; i >= 0; --i {
        fmt.Println(array[i])
    }

    // 所以整段代码空间复杂度为 O(n)

    // 常见的空间复杂度有: O(1)、O(n)、O(n^2)
}
```


## 第四课：复杂度分析（下）- 浅析最好、最坏、平均、均摊时间复杂度
